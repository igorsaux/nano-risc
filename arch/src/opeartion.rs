use std::{fmt::Display, str::FromStr};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Operation {
    Add,
    Sub,
    Mov,
    Mul,
    Div,
    Mod,
    Jmp,
    Dbg,
    Dbgs,
    Yield,
    Beq,
    Beqz,
    Bge,
    Bgez,
    Bgt,
    Bgtz,
    Ble,
    Blez,
    Blt,
    Bltz,
    Bne,
    Bnez,
    Seq,
    Seqz,
    Sge,
    Sgez,
    Sgt,
    Sgtz,
    Sle,
    Slez,
    Slt,
    Sltz,
    Sne,
    Snez,
    Halt,
    Push,
    Pop,
    Peek,
    Ret,
    Call,
    And,
    Or,
    Xor,
    Nor,
    Andi,
    Ori,
    Xori,
    Shr,
    Shl,
    Ror,
    Rol,
    Sqrt,
    Trunc,
    Ceil,
    Floor,
    Max,
    Min,
    Abs,
    Log,
    Exp,
    Inf,
    Nan,
}

impl Display for Operation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Operation::Add => f.write_str("add"),
            Operation::Sub => f.write_str("sub"),
            Operation::Mov => f.write_str("mov"),
            Operation::Mul => f.write_str("mul"),
            Operation::Div => f.write_str("div"),
            Operation::Mod => f.write_str("mod"),
            Operation::Dbg => f.write_str("dbg"),
            Operation::Dbgs => f.write_str("dbgs"),
            Operation::Yield => f.write_str("yield"),
            Operation::Beq => f.write_str("beq"),
            Operation::Beqz => f.write_str("beqz"),
            Operation::Bge => f.write_str("bge"),
            Operation::Bgez => f.write_str("bgez"),
            Operation::Bgt => f.write_str("bgt"),
            Operation::Bgtz => f.write_str("bgtz"),
            Operation::Ble => f.write_str("ble"),
            Operation::Blez => f.write_str("blez"),
            Operation::Blt => f.write_str("blt"),
            Operation::Bltz => f.write_str("bltz"),
            Operation::Bne => f.write_str("bne"),
            Operation::Bnez => f.write_str("bnez"),
            Operation::Seq => f.write_str("seq"),
            Operation::Seqz => f.write_str("seqz"),
            Operation::Sge => f.write_str("sge"),
            Operation::Sgez => f.write_str("sgez"),
            Operation::Sgt => f.write_str("sgt"),
            Operation::Sgtz => f.write_str("sgtz"),
            Operation::Sle => f.write_str("sle"),
            Operation::Slez => f.write_str("slez"),
            Operation::Slt => f.write_str("slt"),
            Operation::Sltz => f.write_str("sltz"),
            Operation::Sne => f.write_str("sne"),
            Operation::Snez => f.write_str("snez"),
            Operation::Halt => f.write_str("halt"),
            Operation::Jmp => f.write_str("jmp"),
            Operation::Push => f.write_str("push"),
            Operation::Pop => f.write_str("pop"),
            Operation::Peek => f.write_str("peek"),
            Operation::Ret => f.write_str("ret"),
            Operation::Call => f.write_str("call"),
            Operation::And => f.write_str("and"),
            Operation::Or => f.write_str("or"),
            Operation::Xor => f.write_str("xor"),
            Operation::Nor => f.write_str("nor"),
            Operation::Andi => f.write_str("andi"),
            Operation::Ori => f.write_str("ori"),
            Operation::Xori => f.write_str("xori"),
            Operation::Shr => f.write_str("shr"),
            Operation::Shl => f.write_str("shl"),
            Operation::Ror => f.write_str("ror"),
            Operation::Rol => f.write_str("rol"),
            Operation::Sqrt => f.write_str("sqrt"),
            Operation::Trunc => f.write_str("trunc"),
            Operation::Ceil => f.write_str("ceil"),
            Operation::Floor => f.write_str("floor"),
            Operation::Max => f.write_str("max"),
            Operation::Min => f.write_str("min"),
            Operation::Abs => f.write_str("abs"),
            Operation::Log => f.write_str("log"),
            Operation::Exp => f.write_str("exp"),
            Operation::Inf => f.write_str("inf"),
            Operation::Nan => f.write_str("nan"),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OpeartionParseError {
    UnknownOperation,
}

impl FromStr for Operation {
    type Err = OpeartionParseError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "add" => Ok(Self::Add),
            "sub" => Ok(Self::Sub),
            "mov" => Ok(Self::Mov),
            "mul" => Ok(Self::Mul),
            "div" => Ok(Self::Div),
            "mod" => Ok(Self::Mod),
            "dbg" => Ok(Self::Dbg),
            "yield" => Ok(Self::Yield),
            "beq" => Ok(Self::Beq),
            "beqz" => Ok(Self::Beqz),
            "bge" => Ok(Self::Bge),
            "bgez" => Ok(Self::Bgez),
            "bgt" => Ok(Self::Bgt),
            "bgtz" => Ok(Self::Bgtz),
            "ble" => Ok(Self::Ble),
            "blez" => Ok(Self::Blez),
            "blt" => Ok(Self::Blt),
            "bltz" => Ok(Self::Bltz),
            "bne" => Ok(Self::Bne),
            "bnez" => Ok(Self::Bnez),
            "seq" => Ok(Self::Seq),
            "seqz" => Ok(Self::Seqz),
            "sge" => Ok(Self::Sge),
            "sgez" => Ok(Self::Sgez),
            "sgt" => Ok(Self::Sgt),
            "sgtz" => Ok(Self::Sgtz),
            "sle" => Ok(Self::Sle),
            "slez" => Ok(Self::Slez),
            "slt" => Ok(Self::Slt),
            "sltz" => Ok(Self::Sltz),
            "sne" => Ok(Self::Sne),
            "snez" => Ok(Self::Snez),
            "halt" => Ok(Self::Halt),
            "jmp" => Ok(Self::Jmp),
            "push" => Ok(Self::Push),
            "pop" => Ok(Self::Pop),
            "peek" => Ok(Self::Peek),
            "ret" => Ok(Self::Ret),
            "call" => Ok(Self::Call),
            "and" => Ok(Self::And),
            "or" => Ok(Self::Or),
            "xor" => Ok(Self::Xor),
            "nor" => Ok(Self::Nor),
            "andi" => Ok(Self::Andi),
            "ori" => Ok(Self::Ori),
            "xori" => Ok(Self::Xori),
            "shr" => Ok(Self::Shr),
            "shl" => Ok(Self::Shl),
            "ror" => Ok(Self::Ror),
            "rol" => Ok(Self::Rol),
            "sqrt" => Ok(Operation::Sqrt),
            "trunc" => Ok(Operation::Trunc),
            "ceil" => Ok(Operation::Ceil),
            "floor" => Ok(Operation::Floor),
            "max" => Ok(Operation::Max),
            "min" => Ok(Operation::Min),
            "abs" => Ok(Operation::Abs),
            "log" => Ok(Operation::Log),
            "exp" => Ok(Operation::Exp),
            "inf" => Ok(Operation::Inf),
            "nan" => Ok(Operation::Nan),
            _ => Err(OpeartionParseError::UnknownOperation),
        }
    }
}
